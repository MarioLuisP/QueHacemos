import 'dart:io';
import 'package:flutter/foundation.dart';
import 'package:device_info_plus/device_info_plus.dart';
import 'notification_service.dart';
import '../models/user_preferences.dart';
import '../services/daily_task_manager.dart';
import 'package:workmanager/workmanager.dart';

enum NotificationConfigState {
  idle,
  detectingPlatform,
  requestingPermissions,
  initializingService,
  configuringWorkManager,
  savingPreferences,
  success,
  errorPermissionDenied,
  errorInitializationFailed,
  errorWorkManagerFailed,
  errorUnknown
}

class NotificationConfigurationService {
  static bool _isConfiguring = false;
  
  /// Configura completamente el sistema de notificaciones
  /// Esta es la √öNICA funci√≥n p√∫blica - maneja todo el proceso costoso
  static Future<NotificationConfigState> configureNotifications() async {
    if (_isConfiguring) {
      print('üîÑ Ya hay una configuraci√≥n en proceso');
      return NotificationConfigState.idle;
    }
    
    _isConfiguring = true;
    
    try {
      print('\nüöÄ === INICIANDO CONFIGURACI√ìN DE NOTIFICACIONES ===');
      
      // PASO 1: Detectar plataforma
      final platformInfo = await _detectPlatform();
      if (platformInfo == null) {
        return _finishWithState(NotificationConfigState.errorUnknown);
      }
      
      // PASO 2: Manejar permisos seg√∫n plataforma
      final permissionsResult = await _handlePermissions(platformInfo);
      if (permissionsResult != NotificationConfigState.initializingService) {
        return _finishWithState(permissionsResult);
      }
      
      // PASO 3: Inicializar NotificationService
      final initResult = await _initializeNotificationService();
      if (initResult != NotificationConfigState.configuringWorkManager) {
        return _finishWithState(initResult);
      }
      
      // PASO 4: Configurar WorkManager/DailyTaskManager
      final workManagerResult = await _configureWorkManager();
      if (workManagerResult != NotificationConfigState.savingPreferences) {
        return _finishWithState(workManagerResult);
      }
      
      // PASO 5: Guardar estado en preferencias
      final prefsResult = await _saveNotificationState();
      if (prefsResult != NotificationConfigState.success) {
        return _finishWithState(prefsResult);
      }
      
      print('‚úÖ === CONFIGURACI√ìN COMPLETADA EXITOSAMENTE ===\n');
      return _finishWithState(NotificationConfigState.success);
      
    } catch (e, stackTrace) {
      print('üí• ERROR INESPERADO en configuraci√≥n: $e');
      print('üìç Stack trace: $stackTrace');
      return _finishWithState(NotificationConfigState.errorUnknown);
    }
  }
  
  static NotificationConfigState _finishWithState(NotificationConfigState state) {
    _isConfiguring = false;
    return state;
  }
  
  /// PASO 1: Detecta plataforma y versi√≥n Android
  static Future<_PlatformInfo?> _detectPlatform() async {
    try {
      print('üîç PASO 1: Detectando plataforma...');
      
      if (Platform.isAndroid) {
        final deviceInfo = DeviceInfoPlugin();
        final androidInfo = await deviceInfo.androidInfo;
        final sdkInt = androidInfo.version.sdkInt;
        
        print('üì± Plataforma: Android ${androidInfo.version.release}');
        print('üî¢ SDK: $sdkInt');
        
        if (sdkInt >= 33) {
          print('‚úÖ Android 13+ detectado - Permisos POST_NOTIFICATIONS requeridos');
          return _PlatformInfo(PlatformType.androidNew, sdkInt);
        } else {
          print('‚úÖ Android <13 detectado - Permisos autom√°ticos');
          return _PlatformInfo(PlatformType.androidOld, sdkInt);
        }
      } else if (Platform.isIOS) {
        final deviceInfo = DeviceInfoPlugin();
        final iosInfo = await deviceInfo.iosInfo;
        print('üçé Plataforma: iOS ${iosInfo.systemVersion}');
        print('‚úÖ iOS detectado - Permisos manejados por NotificationService');
        return _PlatformInfo(PlatformType.ios, 0);
      } else {
        print('‚ùå Plataforma no soportada: ${Platform.operatingSystem}');
        return null;
      }
    } catch (e) {
      print('üí• ERROR detectando plataforma: $e');
      return null;
    }
  }
  
  /// PASO 2: Maneja permisos seg√∫n plataforma
  static Future<NotificationConfigState> _handlePermissions(_PlatformInfo platformInfo) async {
    try {
      print('üîê PASO 2: Manejando permisos...');
      
      switch (platformInfo.type) {
        case PlatformType.androidOld:
          print('‚è≠Ô∏è  Android <13: Saltando solicitud de permisos');
          return NotificationConfigState.initializingService;
          
        case PlatformType.androidNew:
          return await _requestAndroidPermissions();
          
        case PlatformType.ios:
          print('‚è≠Ô∏è  iOS: Permisos ser√°n manejados por NotificationService.initialize()');
          return NotificationConfigState.initializingService;
      }
    } catch (e) {
      print('üí• ERROR manejando permisos: $e');
      return NotificationConfigState.errorUnknown;
    }
  }
  
  /// Solicita permisos espec√≠ficos de Android 13+
  static Future<NotificationConfigState> _requestAndroidPermissions() async {
    try {
      print('üìã Solicitando permiso POST_NOTIFICATIONS...');
      
      final android = NotificationService.resolveAndroid();
      if (android == null) {
        print('‚ùå No se pudo resolver AndroidNotificationPlugin');
        return NotificationConfigState.errorUnknown;
      }
      
      final permissionGranted = await android.requestNotificationsPermission();
      print('üéØ Resultado permiso: $permissionGranted');
      
      if (permissionGranted == true) {
        print('‚úÖ Permisos Android concedidos');
        return NotificationConfigState.initializingService;
      } else if (permissionGranted == false) {
        print('‚ùå Permisos Android denegados por el usuario');
        return NotificationConfigState.errorPermissionDenied;
      } else {
        print('‚ö†Ô∏è  Permisos Android: resultado null (posible error del sistema)');
        // En algunos casos null puede significar "ya otorgado", intentamos continuar
        return NotificationConfigState.initializingService;
      }
    } catch (e) {
      print('üí• ERROR solicitando permisos Android: $e');
      return NotificationConfigState.errorPermissionDenied;
    }
  }
  
  /// PASO 3: Inicializa NotificationService (tareas baratas)
  static Future<NotificationConfigState> _initializeNotificationService() async {
    try {
      print('‚öôÔ∏è  PASO 3: Inicializando NotificationService...');
      
      final initialized = await NotificationService.initialize();
      print('üéØ Resultado inicializaci√≥n: $initialized');
      
      if (initialized) {
        print('‚úÖ NotificationService inicializado correctamente');
        return NotificationConfigState.configuringWorkManager;
      } else {
        print('‚ùå Fall√≥ la inicializaci√≥n de NotificationService');
        return NotificationConfigState.errorInitializationFailed;
      }
    } catch (e) {
      print('üí• ERROR inicializando NotificationService: $e');
      return NotificationConfigState.errorInitializationFailed;
    }
  }
  
  /// PASO 4: Configura WorkManager y DailyTaskManager
  static Future<NotificationConfigState> _configureWorkManager() async {
    try {
      print('üîÑ PASO 4: Configurando WorkManager...');
      
      // Primero cancelar cualquier tarea previa
      await Workmanager().cancelAll();
      print('üßπ WorkManager: tareas previas canceladas');
      
      // Inicializar DailyTaskManager
      final dailyTaskManager = DailyTaskManager();
      dailyTaskManager.initialize();
      print('‚úÖ DailyTaskManager inicializado');
      
      return NotificationConfigState.savingPreferences;
    } catch (e) {
      print('üí• ERROR configurando WorkManager: $e');
      return NotificationConfigState.errorWorkManagerFailed;
    }
  }
  
  /// PASO 5: Guarda el estado final en SharedPreferences
  static Future<NotificationConfigState> _saveNotificationState() async {
    try {
      print('üíæ PASO 5: Guardando estado en preferencias...');
      
      await UserPreferences.setNotificationsReady(true);
      print('‚úÖ Estado guardado: notificationsReady = true');
      
      // Verificar que se guard√≥ correctamente
      final verification = await UserPreferences.getNotificationsReady();
      print('üîç Verificaci√≥n: notificationsReady = $verification');
      
      if (verification) {
        return NotificationConfigState.success;
      } else {
        print('‚ùå Error: no se pudo verificar el estado guardado');
        return NotificationConfigState.errorUnknown;
      }
    } catch (e) {
      print('üí• ERROR guardando preferencias: $e');
      return NotificationConfigState.errorUnknown;
    }
  }
  
  /// Verifica si las notificaciones ya est√°n configuradas
  static Future<bool> isAlreadyConfigured() async {
    try {
      final isReady = await UserPreferences.getNotificationsReady();
      print('üîç Verificaci√≥n configuraci√≥n existente: $isReady');
      return isReady;
    } catch (e) {
      print('üí• ERROR verificando configuraci√≥n: $e');
      return false;
    }
  }
  
  /// Desactiva completamente las notificaciones
  static Future<void> disableNotifications() async {
    try {
      print('\nüî¥ === DESACTIVANDO NOTIFICACIONES ===');
      
      print('üßπ Cancelando todas las tareas de WorkManager...');
      await Workmanager().cancelAll();
      
      print('üíæ Guardando estado: notificationsReady = false');
      await UserPreferences.setNotificationsReady(false);
      
      final verification = await UserPreferences.getNotificationsReady();
      print('üîç Verificaci√≥n: notificationsReady = $verification');
      print('‚úÖ === NOTIFICACIONES DESACTIVADAS ===\n');
    } catch (e) {
      print('üí• ERROR desactivando notificaciones: $e');
    }
  }
}

class _PlatformInfo {
  final PlatformType type;
  final int androidSdk;
  
  _PlatformInfo(this.type, this.androidSdk);
}

enum PlatformType {
  androidOld,   // Android <13
  androidNew,   // Android 13+
  ios
}