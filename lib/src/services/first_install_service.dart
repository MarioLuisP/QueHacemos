// lib/src/services/first_install_service.dart

import 'dart:async';
import 'package:shared_preferences/shared_preferences.dart';
import '../sync/firestore_client.dart';
import '../data/repositories/event_repository.dart';
import '../providers/notifications_provider.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import '../cache/event_cache_service.dart';
import '../sync/sync_service.dart';
import 'dart:io';
import 'package:device_info_plus/device_info_plus.dart';
import 'package:onesignal_flutter/onesignal_flutter.dart';
import 'package:flutter_dotenv/flutter_dotenv.dart';
import '../models/user_preferences.dart';

/// üöÄ SERVICIO AUT√ìNOMO DE PRIMERA INSTALACI√ìN
/// Responsabilidad √∫nica: Setup t√©cnico completo de la app
/// Ejecuta UNA SOLA VEZ en la vida de la app
class FirstInstallService {
  static final FirstInstallService _instance = FirstInstallService._internal();
  factory FirstInstallService() => _instance;

  FirstInstallService._internal() {
    // Escuchar completions de sync diario para actualizar cache
    SyncService.onSyncComplete.listen((result) {
      if (result.success && result.eventsAdded > 0) {
        _refreshSimpleHomeProvider();
      }
    });
  }

  // Flag independiente para primera instalaci√≥n
  static const String _firstInstallKey = 'first_install_completed';

  // Componentes necesarios
  final FirestoreClient _firestoreClient = FirestoreClient();
  final EventRepository _eventRepository = EventRepository();
  final NotificationsProvider _notificationsProvider = NotificationsProvider.instance;

  // Control de proceso
  bool _isRunning = false;

  // ========== M√âTODO PRINCIPAL ==========

  /// üéØ Verificar si necesita primera instalaci√≥n
  Future<bool> needsFirstInstall() async {
    final prefs = await SharedPreferences.getInstance();
    return !(prefs.getBool(_firstInstallKey) ?? false);
  }

  /// üöÄ Ejecutar primera instalaci√≥n completa
  Future<FirstInstallResult> performFirstInstall() async {
    if (_isRunning) {
      return FirstInstallResult.alreadyRunning();
    }

    _isRunning = true;

    try {
      print('üöÄ Iniciando primera instalaci√≥n...');

      // 1. Verificaci√≥n inicial
      if (!await needsFirstInstall()) {
        print('‚úÖ Primera instalaci√≥n ya completada previamente');
        return FirstInstallResult.alreadyCompleted();
      }

      // 2. Preparaci√≥n t√©cnica
      await _prepareTechnicalSetup();

      // 3. Descarga con reintentos (ahora retorna documentos completos)
      final completeBatches = await _downloadInitialContent();

      // 4. Procesamiento de datos (ahora secuencial por lote)
      await _processInitialData(completeBatches);

      // 5. Finalizaci√≥n exitosa
      await _markFirstInstallCompleted();
      await _setInitialSyncTimestamp(); // ‚Üê MOVIDO AQU√ç

      // Contar total de eventos para notificaci√≥n
      final totalEvents = completeBatches.fold<int>(0, (sum, batch) {
        final eventos = (batch['eventos'] as List<dynamic>?) ?? [];
        return sum + eventos.length;
      });

      await _notifySuccess(totalEvents);

      print('üéâ Primera instalaci√≥n completada exitosamente');
      return FirstInstallResult.success(eventsDownloaded: totalEvents);

    } catch (e) {
      print('‚ùå Error en primera instalaci√≥n: $e');
      await _notifyError(e);
      return FirstInstallResult.error(e.toString());
    } finally {
      _isRunning = false;
    }
  }

  /// üìÖ Marcar sync como reci√©n hecho (evitar recovery inmediato)
  Future<void> _setInitialSyncTimestamp() async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setString('last_sync_timestamp', DateTime.now().toIso8601String());
    print('‚è∞ Timestamp de sync inicial seteado');
  }
  // ========== M√âTODOS INTERNOS ==========

  /// üîß Preparaci√≥n t√©cnica inicial
  Future<void> _prepareTechnicalSetup() async {
    print('üîß Preparando setup t√©cnico...');

    // Inicializar base de datos (auto-creaci√≥n de tablas)
    await _eventRepository.getTotalEvents(); // Trigger database creation
// Inicializar OneSignal para Android <13 (permisos autom√°ticos)
    if (Platform.isAndroid) {
      final deviceInfo = DeviceInfoPlugin();
      final androidInfo = await deviceInfo.androidInfo;

      if (androidInfo.version.sdkInt < 33) {
        print('üì± Android <13 detectado - inicializando OneSignal...');
        try {
          OneSignal.initialize(dotenv.env['ONESIGNAL_APP_ID']!);

          // Obtener y mostrar el token
          final userId = OneSignal.User.pushSubscription.id;
          final token = OneSignal.User.pushSubscription.token;
          await UserPreferences.setOneSignalInitialized(true);
          await UserPreferences.setNotificationsReady(true);
          print('‚úÖ OneSignal inicializado en primera instalaci√≥n');
        } catch (e) {
          print('‚ö†Ô∏è Error inicializando OneSignal: $e');
        }
      }
    }


    print('‚úÖ Base de datos SQLite inicializada');
  }

  /// üî• Descarga de contenido inicial con reintentos (AUT√ìNOMO)
  Future<List<Map<String, dynamic>>> _downloadInitialContent() async {
    const int maxRetries = 3;
    const Duration retryDelay = Duration(seconds: 2);

    for (int attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        print('üî• Intento $attempt/$maxRetries: Descargando 10 lotes iniciales...');

        // NUEVA L√ìGICA AUT√ìNOMA - Sin FirestoreClient
        final events = await _downloadFromFirestore();

        if (events.isEmpty) {
          throw Exception('No se encontraron eventos en el servidor');
        }

        print('‚úÖ Descarga exitosa: ${events.length} lotes');
        return events;

      } catch (e) {
        print('‚ùå Intento $attempt fall√≥: $e');

        if (attempt == maxRetries) {
          throw NetworkException('Error de conexi√≥n despu√©s de $maxRetries intentos: $e');
        }

        print('‚è≥ Esperando ${retryDelay.inSeconds} segundos antes del siguiente intento...');
        await Future.delayed(retryDelay);
      }
    }

    throw Exception('Error inesperado en descarga');
  }

  /// üì• Descarga directa desde Firestore (retorna documentos completos)
  Future<List<Map<String, dynamic>>> _downloadFromFirestore() async {
    try {
      final querySnapshot = await FirebaseFirestore.instance
          .collection('eventos_lotes')
          .orderBy('metadata.fecha_subida', descending: true)
          .limit(10)
          .get();

      if (querySnapshot.docs.isEmpty) {
        print('üî≠ No hay lotes disponibles en Firestore');
        return [];
      }

      // Retornar documentos completos con metadata + eventos
      final completeBatches = querySnapshot.docs
          .map((doc) => doc.data() as Map<String, dynamic>)
          .toList();

      print('üì¶ Primera instalaci√≥n: ${completeBatches.length} lotes descargados');

      // Actualizar versi√≥n del lote m√°s reciente (como antes)
      final newBatchVersion = completeBatches.first['metadata']?['nombre_lote'] as String? ?? 'multiple';

      // Contar total de eventos de todos los lotes
      final totalEvents = completeBatches.fold<int>(0, (sum, batch) {
        final eventos = (batch['eventos'] as List<dynamic>?) ?? [];
        return sum + eventos.length;
      });

      await _eventRepository.updateSyncInfo(
        batchVersion: newBatchVersion,
        totalEvents: totalEvents,
      );

      return completeBatches;

    } catch (e) {
      print('‚ùå Error descargando de Firestore: $e');
      rethrow;
    }
  }

  /// ‚öôÔ∏è Procesamiento de datos iniciales (secuencial por lote)
  Future<void> _processInitialData(List<Map<String, dynamic>> completeBatches) async {
    if (completeBatches.isEmpty) {
      print('‚öôÔ∏è No hay lotes para procesar');
      return;
    }

    // Ordenar lotes por fecha ascendente (del m√°s antiguo al m√°s nuevo)
    completeBatches.sort((a, b) {
      final fechaA = a['metadata']?['fecha_subida'] as String? ?? '';
      final fechaB = b['metadata']?['fecha_subida'] as String? ?? '';
      return fechaA.compareTo(fechaB);
    });

    print('‚öôÔ∏è Procesando ${completeBatches.length} lotes en orden cronol√≥gico...');

    int totalEventosInsertados = 0;
    int totalDuplicadosRemovidos = 0;
    int totalEventosLimpiados = 0;
    int totalFavoritosLimpiados = 0;

    // Procesar cada lote secuencialmente (simulando comportamiento diario)
    for (int i = 0; i < completeBatches.length; i++) {
      final batch = completeBatches[i];
      final metadata = batch['metadata'] as Map<String, dynamic>?;
      final eventos = (batch['eventos'] as List<dynamic>?)
          ?.map((e) => Map<String, dynamic>.from(e as Map))
          .toList() ?? [];

      final nombreLote = metadata?['nombre_lote'] ?? 'lote_${i + 1}';
      final fechaSubida = metadata?['fecha_subida'] ?? 'unknown';

      print('üì¶ Procesando lote ${i + 1}/${completeBatches.length}: $nombreLote');
      print('   üìÖ Fecha: $fechaSubida');
      print('   üìä Eventos: ${eventos.length}');

      if (eventos.isEmpty) {
        print('   ‚ö†Ô∏è Lote vac√≠o, saltando...');
        continue;
      }

      // 1. Insertar eventos del lote actual
      await _eventRepository.insertEvents(eventos);
      totalEventosInsertados += eventos.length;
      print('   ‚úÖ Eventos insertados: ${eventos.length}');

      // 2. Remover duplicados (igual que sync diario)
      final duplicadosRemovidos = await _eventRepository.removeDuplicatesByCodes();
      totalDuplicadosRemovidos += duplicadosRemovidos;
      if (duplicadosRemovidos > 0) {
        print('   üîÑ Duplicados removidos: $duplicadosRemovidos');
      }

      // 3. Limpiar eventos viejos (igual que sync diario)
      final cleanupResults = await _eventRepository.cleanOldEvents();
      final eventosLimpiados = cleanupResults['normalEvents'] ?? 0;
      final favoritosLimpiados = cleanupResults['favoriteEvents'] ?? 0;

      totalEventosLimpiados += eventosLimpiados;
      totalFavoritosLimpiados += favoritosLimpiados;

      if (eventosLimpiados > 0 || favoritosLimpiados > 0) {
        print('   üßπ Limpieza: $eventosLimpiados eventos, $favoritosLimpiados favoritos');
      }

      print('   ‚úÖ Lote $nombreLote procesado completamente\n');
    }

    // Resumen final
    print('üéØ Procesamiento secuencial completado:');
    print('   üìä Total eventos insertados: $totalEventosInsertados');
    print('   üîÑ Total duplicados removidos: $totalDuplicadosRemovidos');
    print('   üßπ Total eventos limpiados: $totalEventosLimpiados');
    print('   ‚ù§Ô∏è Total favoritos limpiados: $totalFavoritosLimpiados');

    // Actualizar cache
    await _refreshSimpleHomeProvider();
  }

  /// ‚úÖ Marcar primera instalaci√≥n como completada
  Future<void> _markFirstInstallCompleted() async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setBool(_firstInstallKey, true);
    print('‚úÖ Flag de primera instalaci√≥n marcado PERMANENTEMENTE');
  }

  /// üéâ Notificar √©xito de primera instalaci√≥n
  Future<void> _notifySuccess(int eventsCount) async {
    await _notificationsProvider.addNotification(
      title: 'üé≠ ¬°App lista para usar!',
      message: 'Se configuraron $eventsCount eventos culturales de C√≥rdoba',
      type: 'first_install_complete',
    );
  }

  /// ‚ö†Ô∏è Notificar error de primera instalaci√≥n
  Future<void> _notifyError(dynamic error) async {
    String title;
    String message;

    if (error is NetworkException) {
      title = 'üì° Sin conexi√≥n a internet';
      message = 'No se pudieron descargar los eventos. La app intentar√° autom√°ticamente m√°s tarde';
    } else {
      title = '‚ö†Ô∏è Error de configuraci√≥n';
      message = 'Error interno de la app, se reintentar√° en la pr√≥xima apertura';
    }

    await _notificationsProvider.addNotification(
      title: title,
      message: message,
      type: 'first_install_error',
    );
  }

  // ========== M√âTODOS DE ESTADO ==========

  /// üìä Obtener estado actual de primera instalaci√≥n
  Future<Map<String, dynamic>> getInstallationStatus() async {
    final isCompleted = !await needsFirstInstall();

    return {
      'completed': isCompleted,
      'running': _isRunning,
      'needsInstall': await needsFirstInstall(),
    };
  }

  /// üîÑ Reset para testing/debug (solo development)
  Future<void> resetFirstInstallFlag() async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.remove(_firstInstallKey);
    print('üîÑ Flag de primera instalaci√≥n reseteado para testing');
  }
  /// üîÑ Actualizar SimpleHomeProvider tras sync o primera instalaci√≥n
  Future<void> _refreshSimpleHomeProvider() async {
    try {
      print('üîÑ Actualizando cache de SimpleHomeProvider...');

      // Obtener instancia desde Provider.of en context global
      // Como no tenemos context aqu√≠, usaremos el EventCacheService directamente
      final EventCacheService cacheService = EventCacheService();
      await cacheService.reloadCache();

      print('‚úÖ Cache actualizado correctamente');
    } catch (e) {
      print('‚ö†Ô∏è Error actualizando cache: $e');
    }
  }
}

// ========== MODELOS DE RESULTADO ==========

/// Resultado de primera instalaci√≥n
class FirstInstallResult {
  final bool success;
  final String? error;
  final int eventsDownloaded;
  final FirstInstallResultType type;

  FirstInstallResult._({
    required this.success,
    this.error,
    this.eventsDownloaded = 0,
    required this.type,
  });

  factory FirstInstallResult.success({required int eventsDownloaded}) =>
      FirstInstallResult._(
        success: true,
        eventsDownloaded: eventsDownloaded,
        type: FirstInstallResultType.success,
      );

  factory FirstInstallResult.alreadyCompleted() =>
      FirstInstallResult._(
        success: true,
        type: FirstInstallResultType.alreadyCompleted,
      );

  factory FirstInstallResult.alreadyRunning() =>
      FirstInstallResult._(
        success: false,
        error: 'Primera instalaci√≥n ya en progreso',
        type: FirstInstallResultType.alreadyRunning,
      );

  factory FirstInstallResult.error(String error) =>
      FirstInstallResult._(
        success: false,
        error: error,
        type: FirstInstallResultType.error,
      );
}

enum FirstInstallResultType {
  success,
  alreadyCompleted,
  alreadyRunning,
  error
}


/// Excepci√≥n espec√≠fica para errores de red
class NetworkException implements Exception {
  final String message;
  NetworkException(this.message);

  @override
  String toString() => 'NetworkException: $message';
}